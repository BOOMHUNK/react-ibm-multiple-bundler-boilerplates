import { useRef, useEffect, useCallback, useState } from "react";
import { Root, createRoot } from "react-dom/client";

type RootElementOptions = {
  tag?: 'div' | 'span';
  style?: string;
  class?: string;
}




export default function useJSXRenderer<T extends HTMLElement>(
  element: T | null, jsx: React.ReactNode, rootElementOptions?: RootElementOptions
): [render: () => void, remove: () => void] {

  const containerRef = useRef<HTMLElement | null>(null);
  const elementRef = useRef<HTMLElement | null>(null);
  const rootRef = useRef<Root | null>();
  const containerClass = "dom-dummy-element";

  const [isRendered, setIsRendered] = useState(false);
  const lastJSX = jsx;


  useEffect(() => {

    const renderTimeout = setTimeout(() => {

      if ((element && !rootRef.current)) {

        containerRef.current = document.createElement(`${rootElementOptions?.tag ? rootElementOptions.tag : 'div'}`);

        containerRef.current.setAttribute('class', containerClass);
        rootElementOptions?.class && containerRef.current.setAttribute('class', rootElementOptions.class);
        containerRef.current.setAttribute('style', ` ${rootElementOptions?.style ? rootElementOptions.style + " " : "width: 100%; height: 100%; "}`);
        console.log("component mount");
        rootRef.current = createRoot(containerRef.current);

        rootRef.current.render(jsx);
        element.appendChild(containerRef.current)
        elementRef.current = element;
      }
      // else if (element && rootRef.current) {
      //   rootRef.current.unmount();

      // }
    });
    return () => {
      clearTimeout(renderTimeout);
      // if (containerRef.current?.innerHTML) containerRef.current.innerHTML = '';
      // const root = rootRef.current;
      // rootRef.current = null;

      // setTimeout(() => {
      //   if (root) {
      //     console.log("component unmount");
      //     root.unmount();
      //   }
      // });
    };
  }, [element, rootElementOptions?.style, rootElementOptions?.class, rootElementOptions?.tag]);


  const render = useCallback<() => void>(
    () => {
      if (rootRef.current && containerRef.current) {

        // rootRef.current.render(jsx);
        // setIsRendered(true);
      }
    },
    [jsx]
  );

  useEffect(() => {
    if (element && containerRef.current && rootRef.current) {
      containerRef.current?.parentNode?.removeChild(containerRef.current);

      rootRef.current.render(jsx);
    }
  }, [element, jsx]);

  function remove() {
    if (elementRef.current) {

      const exisiting = elementRef.current?.getElementsByClassName(".dom-dummy-element")[0];
      console.log("removing existing: ", containerRef.current?.parentNode);
      containerRef.current?.parentNode?.removeChild(containerRef.current);
      // if (exisiting)
      //   elementRef.current?.removeChild(exisiting);
    }
    else console.log("no element given");



    const root = rootRef.current;
    rootRef.current = null;
    setTimeout(() => { if (root) root.unmount(); });
    // setIsRendered(false);

  }

  return [render, remove];
}
